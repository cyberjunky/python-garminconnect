[project]
name = "garminconnect"
version = "0.2.38"
description = "Python 3 API wrapper for Garmin Connect"
authors = [
    {name = "Ron Klinkien", email = "ron@cyberjunky.nl"},
]
dependencies = [
    "garth>=0.5.17,<0.7.0",
]
readme = "README.md"
license = {text = "MIT"}
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
    "License :: OSI Approved :: MIT License",
    "Operating System :: MacOS :: MacOS X",
    "Operating System :: Microsoft :: Windows",
    "Operating System :: POSIX :: Linux",
    "Operating System :: OS Independent",
]
keywords=["garmin connect", "api", "garmin"]
requires-python=">=3.10"
[project.urls]
"Homepage" = "https://github.com/cyberjunky/python-garminconnect"
"Issues" = "https://github.com/cyberjunky/python-garminconnect/issues"
"Changelog" = "https://github.com/cyberjunky/python-garminconnect/releases"

[build-system]
requires = ["pdm-backend"]
build-backend = "pdm.backend"

[tool.pytest.ini_options]
addopts = "--ignore=__pypackages__ --ignore-glob=*.yaml"

[tool.mypy]
ignore_missing_imports = true
python_version = "3.10"
disallow_untyped_defs = true
warn_unused_ignores = true

[tool.isort]
profile = "black"
line_length = 88
known_first_party = "garminconnect"
skip_glob = ["tests/*", "test_data/*"]

[project.optional-dependencies]
dev = [
    "ipython",
    "ipdb",
    "ipykernel",
    "pandas",
    "matplotlib",
]
workout = [
    "pydantic>=2.0.0",
]
linting = [
    "black[jupyter]",
    "ruff",
    "mypy",
    "isort",
    "types-requests",
]
testing = [
    "coverage",
    "pytest",
    "pytest-vcr>=1.0.2",
    "vcrpy>=7.0.0",
]
example = [
    "garth>=0.5.17,<0.7.0",
    "requests",
    "readchar",
]

[tool.pdm]
distribution = true

[tool.pdm.build]
excludes = [
  "tests/**",
  "test_data/**",
  ".github/**",
]

[tool.ruff]
line-length = 88
target-version = "py310"
exclude = [
    ".git",
    ".venv",
    "__pycache__",
    ".pytest_cache",
    "build",
    "dist",
    "tests",
    "test_data",
]

[tool.ruff.lint]
select = [
    "E",    # pycodestyle errors
    "W",    # pycodestyle warnings
    "F",    # pyflakes
    "I",    # isort
    "B",    # flake8-bugbear
    "C4",   # flake8-comprehensions
    "UP",   # pyupgrade
    "ARG",  # flake8-unused-arguments
    "SIM",  # flake8-simplify
    "S",    # flake8-bandit (security)
    "D",    # pydocstyle (docstring conventions)
    "PTH",  # flake8-use-pathlib
    "PL",   # pylint (subset of rules)
    "RUF",  # ruff-specific rules
    "TRY",  # tryceratops (exception handling)
    "PERF", # perflint (performance anti-patterns)
    "LOG",  # flake8-logging (logging best practices)
    "G",    # flake8-logging-format
    "T20",  # flake8-print (no print statements)
    "PIE",  # flake8-pie (miscellaneous lints)
    "RET",  # flake8-return (return statement checks)
    "TCH",  # flake8-type-checking (type checking imports)
    "ERA",  # eradicate (commented-out code)
]
ignore = [
    "E501",   # line too long, handled by black
    "B008",   # do not perform function calls in argument defaults
    "C901",   # too complex
    # Docstring rules - relax initially
    "D100",   # missing docstring in public module
    "D104",   # missing docstring in public package
    "D105",   # missing docstring in magic method
    "D107",   # missing docstring in __init__
    "D203",   # 1 blank line required before class docstring (conflicts with D211)
    "D213",   # multi-line docstring summary should start at second line (conflicts with D212)
    # Pylint rules - API wrapper has complex functions by nature
    "PLR0913", # too many arguments to function call
    "PLR2004", # magic value used in comparison
    "PLR0912", # too many branches (complex API methods)
    "PLR0915", # too many statements (complex API methods)
    "PLC0415", # import outside top-level (delayed imports for optional deps)
    # Exception handling - these patterns are intentional
    "TRY003", # avoid specifying long messages outside exception class
    "TRY004", # type-check-without-type-error (used for input validation)
    "TRY301", # raise-within-try (re-raising with context is intentional)
    # Logging - f-strings are fine in Python 3.10+
    "G004",   # logging-f-string (performance not an issue here)
    # Docstring style - these are stylistic preferences
    "D205",   # missing-blank-line-after-summary (minor formatting)
    "D401",   # non-imperative-mood (stylistic)
    "D102",   # undocumented-public-method (gradual adoption)
    "D106",   # undocumented-public-nested-class
    "D417",   # undocumented-param (gradual adoption)
    # Exception handling edge cases
    "TRY401", # verbose-log-message (intentional for debugging)
    "TRY203", # useless-try-except (sometimes needed for clarity)
    "TRY300", # try-consider-else (style preference)
    # Commented code - sometimes useful as documentation
    "ERA001", # commented-out-code (explanatory comments)
]
unfixable = []  # Allow all fixes, including unsafe ones

[tool.ruff.lint.per-file-ignores]
"tests/*" = ["ARG", "S101"]
"garminconnect/fit.py" = ["D", "RUF012", "PLW2901"]  # FIT protocol utility - stable, minimal docs
"garminconnect/workout.py" = ["D401"]  # Pydantic models - docstring mood is fine
"demo.py" = ["T20", "S101", "ERA", "RUF001", "PTH", "PERF401", "PERF203", "PLR0911", "D103"]  # Demo script - various user-facing patterns
"example.py" = ["S110", "PLR0911", "T20"]  # Example script - simple error handling is intentional

[tool.coverage.run]
source = ["garminconnect"]
omit = [
    "*/tests/*",
    "*/test_*",
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if settings.DEBUG",
    "raise AssertionError",
    "raise NotImplementedError",
    "if 0:",
    "if __name__ == \"__main__\":",
    "@(abc\\.)?abstractmethod",
]
[tool.pdm.scripts]
# Development workflow
install = "pdm install --group :all"
format = {composite = ["pdm run ruff check . --fix --unsafe-fixes", "pdm run isort . --skip-gitignore", "pdm run black -l 88 ."]}
lint = {composite = ["pdm run isort --check-only . --skip-gitignore", "pdm run ruff check .", "pdm run black -l 88 . --check --diff", "pdm run mypy garminconnect tests"]}
test = {cmd = "pdm run coverage run -m pytest -v --durations=10"}
testcov = {composite = ["test", "pdm run coverage html", "pdm run coverage xml -o coverage/coverage.xml"]}
codespell = "pre-commit run codespell --all-files"
clean = "python -c \"import shutil, pathlib; [shutil.rmtree(p, ignore_errors=True) for p in pathlib.Path('.').rglob('__pycache__')]; [p.unlink(missing_ok=True) for p in pathlib.Path('.').rglob('*.py[co]')]\""

# Pre-commit hooks
pre-commit-install = "pre-commit install"
pre-commit-run = "pre-commit run --all-files"
pre-commit-run-staged = "pre-commit run"
pre-commit-update = "pre-commit autoupdate"

# Publishing
build = "pdm build"
publish = {composite = ["build", "pdm publish"]}

# VCR cassette management
record-vcr = {env = {GARMINTOKENS = "~/.garminconnect"}, cmd = "pdm run pytest tests/test_garmin.py -v --vcr-record=new_episodes"}
clean-vcr = "python3 -c \"import pathlib; p=pathlib.Path('tests/cassettes'); [f.unlink() for f in p.glob('*.yaml')]\""
reset-vcr = {composite = ["clean-vcr", "record-vcr"]}

# Quality checks
all = {composite = ["lint", "codespell", "pre-commit-run", "test"]}

[tool.pdm.dev-dependencies]
dev = [
    "ipython",
    "ipdb",
    "ipykernel",
    "pandas",
    "matplotlib",
]
linting = [
    "black[jupyter]",
    "ruff",
    "mypy",
    "isort",
    "types-requests",
    "pre-commit",
    "codespell",
]
testing = [
    "coverage",
    "pytest",
    "pytest-vcr>=1.0.2",
    "vcrpy>=7.0.0",
]
example = [
    "readchar",
]
